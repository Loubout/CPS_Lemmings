Service : GameEng
Types : bool, int, enum Nature{EMPTY, DIRT, METAL},
				   enum Status{LIVING, DEAD, SAVED},
				   enum Specialty{CLIMBER, DIGGER, STOPPER,	BASHER,	BUILDER, MINER, FLOATER, BOMBER}
Observators :
    const sizeColony : [GameEng] -> int
    const spawnSpeed : [GameEng] -> int
    timeSinceLastSpawn: [GameEng] -> int
    isObstacle: [GameEng] x int x int -> bool
        pre isObstacle(e, x, y) require 0 < x < Level : width(getLevel(e)) ^ 0 < y < Level : height(getLevel(e))
    isDirt : [GameEng] x int x int -> bool
        pre isDirt(e, x, y) require 0 < x < Level : width(getLevel(e)) ^ 0 < y < Level : height(getLevel(e)
   
    gameOver: [GameEng] -> bool
    getLevel: [GameEng] -> Level
    nbTours: [GameEng] -> int
    score: [GameEng] -> (int, int)
        pre score(e) require gameOver(e)
    nbSpawned: [GameEng -> int
    nbSauves: [GameEng] -> int   
    nbActif: [GameEng] -> int    
    getLemmingsNum : [GameEng] -> Set<Int>
    lemmingExiste: [GameEng] x int -> bool
    getLemming: [GameEng] x int -> Lemming
        pre getLemming(e, n) require lemmingExiste(e, n)
    isThereLemming : [GameEng] x int x int -> bool
    	pre isThereLemming(e, x, y) require 0 < x < Level : width(getLevel(e)) ^ 0 < y < Level : height(getLevel(e)) 
    getLemmingAtPosition : [GameEng] x int x int -> [Lemming]
    	pre getLemmingAtPosition(e, x, y) require isThereLemming(e, x, y)
    getLemmingX : [GameEng] x int -> int 
        pre getLemmingX(e, i) require lemmingExiste(i)
    getLemmingY : [GameEng] x int -> int 
        pre getLemmingY(e, i) require lemmingExiste(i)
    active: [GameEng] x int  -> bool
        pre active(e, n) require 1 < n =< nbActif
    
    
Constructors :
    init: int x int -> [Level]
        pre init(size, sp) require size > 0 ^ sp > 0
    
Operators :
    nextTurn : [GameEng] ->  [GameEng]
        pre nextTurn(e) require not gameOver(e)
Observations :
    [invariants]
        nbSpawned(e) =< sizeColony(e)
        nbTours(e) => 0
        nbActifs(e) =min= |getLemmingsNum(e)|
        lemmingExiste(e, n) =min= n \belongsto getLemmingsNum(e)
        gameOver(e) =min= (nbSpawned(e) == sizeColony(e)) ^ (nbActif(e) == 0)     
    [init]
        sizeColony(init(x,y)) == x
        spawnSpeed(init(x,y)) == y
        score(init(x, y)) == 0
        gameOver(init(x,y)) == FALSE
        nbTours(init(x, y)) == 0
        nbSpawned(init(x, y)) == 0
        nbSauves(init(x, y)) == 0
        nbActif(init(x, y)) == 0
        getAllLemmings(init(x, y)) == Nil
    [nextTurn]
        \forall n in getLemmingsNum(e) getLemming(nexTurn(e), n) == Lemming : step(getLemming(e, n))
                                       ^ ((Lemming : hasSpecial(getLemming(e, n), BOMBER ^ Lemming : getBombCounter(getLemming(e, n)) == 5) =>
                                             isDirt(e, getLemmingX(e, n), getLemmingY(e, n)+1) 
                                                => Level : remove(getX(l), getY(l)+1)
                                             ^ isDirt(e, getLemmingX(e, n)-1, getLemmingY(e, n)+1) 
                                                => Level : remove(getX(l)-1, getY(l)+1)
                                             ^ isDirt(e, getLemmingX(e, n)-1, getLemmingY(e, n)) 
                                                => Level : remove(getX(l)-1, getY(l))
                                             ^ isDirt(e, getLemmingX(e, n)-2, getLemmingY(e, n)) 
                                                 => Level : remove(getX(l)-2, getY(l))
                                             ^ isDirt(e, getLemmingX(e, n)-1, getLemmingY(e, n)-1) 
                                                => Level : remove(getX(l)-1, getY(l)-1)
                                             ^ isDirt(e, getLemmingX(e, n)-2, getLemmingY(e, n)-1) 
                                                => Level : remove(getX(l)-2, getY(l)-1)
                                             ^ isDirt(e, getLemmingX(e, n)-1, getLemmingY(e, n)-2) 
                                                 => Level : remove(getX(l)-1, getY(l)-1)
                                             ^ isDirt(e, getLemmingX(e, n), getLemmingY(e, n)-2) 
                                                => Level : remove(getX(l), getY(l)-2)
                                             ^ isDirt(e, getLemmingX(e, n)+1, getLemmingY(e, n)-2) 
                                                => Level : remove(getX(l)+1, getY(l)-2)
                                             ^ isDirt(e, getLemmingX(e, n)+1, getLemmingY(e, n)-1) 
                                                => Level : remove(getX(l)+1, getY(l)-1)
                                             ^ isDirt(e, getLemmingX(e, n)+2, getLemmingY(e, n)-1) 
                                                => Level : remove(getX(l)+2, getY(l)-1)
                                             ^ isDirt(e, getLemmingX(e, n)+1, getLemmingY(e, n)) 
                                                => Level : remove(getX(l)+1, getY(l))
                                             ^ isDirt(e, getLemmingX(e, n)+2, getLemmingY(e, n)) 
                                                => Level : remove(getX(l)+2, getY(l))
                                             ^ isDirt(e, getLemmingX(e, n)+1, getLemmingY(e, n)+1) 
                                                => Level : remove(getX(l)+1, getY(l)+1)                                               
                                        ^ (Lemming : getType(step(getLemming(e, n)) == DIGGER =>
                                            Level : remove(getX(l), getY(l)+1)
                                            ^ isDirt(e, getLemmingX(e, n)-1, getLemmingY(e, n)+1) 
                                                => Level : remove(getX(l)-1, getY(l)+1)
                                            ^ isDirt(e, getLemmingX(e, n)+1, getLemmingY(e, n)+1) 
                                                => Level : remove(getX(l)+1, getY(l)+1)
                                        ^ (Lemming : getType(step(getLemming(e, n)) ==  BASHER =>
                                            (Lemming : getDirection(getLemming(e,n)) == RIGHT =>
                                                Level : remove(getX(l)+1, getY(l))
                                                ^Level : remove(getX(l)+1, getY(l)-1)
                                                ^Level : remove(getX(l)+1, getY(l)-2)
                                            (Lemming : getDirection(getLemming(e,n)) == LEFT =>
                                                Level : remove(getX(l)-1, getY(l))
                                                ^Level : remove(getX(l)-1, getY(l)-1)
                                                ^Level : remove(getX(l)-1, getY(l)-2)
                                        ^ (Lemming : getType(step(getLemming(e, n)) ==  BUILDER =>
                                             (Lemming : getDirection(getLemming(e,n)) == RIGHT =>
                                                Level : build(getX(l)+1, getY(l))
                                                ^Level : build(getX(l)+2, getY(l))
                                                ^Level : build(getX(l)+3, getY(l))
                                            (Lemming : getDirection(getLemming(e,n)) == LEFT =>
                                                Level : build(getX(l)-1, getY(l))
                                                ^Level : build(getX(l)-2, getY(l))
                                                ^Level : build(getX(l)-3, getY(l))
                                       
            timeSinceLastSpawn(nextTurn(e)) = timeSinceLastSpawn(e) + 1
        else 
            timeSinceLastSpawn(nextTurn(e)) = 0 
            ^ nbSpawned((nextTurn(e)) = nbSpawned(e) + 1
            ^ getLemming(e, nbSpawned(e) + 1) == Lemming : init(FALLER, nbSpawned(e) +1)